
##
##    The Oracle Storage HCL Testkit is a suite of tests for certifying
##    storage with Oracle VM (OVM).
##    Copyright (C) 2013 Oracle USA, Inc 
##
##    This file is part of the Oracle Storage HCL Testkit.
##
##    The Oracle Storage HCL Testkit is free software; you can redistribute 
##    it and/or modify it under the terms of the GNU General Public License 
##    as published by the Free Software Foundation; either version 2 of the 
##    License, or (at your option) any later version.
##
##    The Oracle Storage HCL Testkit is distributed in the hope that it will
##    be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
##    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with the Oracle Storage HCL Testkit.  If not; write to the 
##    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
##    Boston, MA 02110-1301 USA. Or see <http://www.gnu.org/licenses/>.
##


#######################################################################
#######################################################################
###  
###
###
###
###
###
###
#######################################################################
#######################################################################


## It's not necessary to print out all of the 
## info all of the time, but when more detail
## is requested, we can do that...
proc send_verbose {message} {
    global VERBOSE
    
    if {$VERBOSE == 1} {
	send_user $message
    }
}


## SSH into the manager to begin the CLI session.
proc OVMlogin {} {

    global prompt
    global ovmUser
    global adminServer
    global ovmPassword
    global spawn_id

    set timeout 900

    send_user "\n\nLogging into to the OVM Manager: $adminServer\n"
    spawn ssh -l $ovmUser $adminServer -p 10000
    expect {
	-re ".*Are you sure you want to continue connecting.*?" {
	    send_user "$expect_out(buffer)\nSending yes to the host....\n"; 
	    send "yes\r";
	    exp_continue}  
	-re ".*ssh: connect.*" {
	    send_user "$expect_out(buffer)\nUnable to connect to the OVM Manager.\n"
	    send_user "Please check your network connection and try again.\n";
	    finishRun 2}
	"Permission denied, please try again" {
	    send_user "$expect_out(buffer)\nUnable to login to the OVM Manager using the admin password provided.\n"
	    send_user "Please verify that the password is correct and run the script again.\n\n"
	    finishRun 2}
	"password:" {
	    send_user "\nSending password...\n"; 
	    send "$ovmPassword\r";
	    exp_continue}
	-re ".*Host key verification failed.*\n" {
	    send_user "$expect_out(buffer)\n";
	    finishRun 2}                 
	-re "(.*)$prompt" {}
	eof {
	    send_user "\nThe ssh session with the OVM Manager has been terminated unexpectedly!"
	    finishRun 9}
    }

    expect "*"

}


proc NodeLogin {} {

    global ServerName
    global Password
    global spawn_id

    send_user "\n\nLogging into to $ServerName\n"    
    spawn ssh -l root $ServerName
    expect {
	-re ".*Are you sure you want to continue connecting.*?" {
	    send_user "$expect_out(buffer)\nSending yes to the host....\n"; 
	    send "yes\r";
	    exp_continue}  
	-re ".*ssh: connect.*" {
	    send_user "$expect_out(buffer)\nUnable to connect to the OVM Manager.\n"
	    send_user "Please check your network connection and try again.\n";
	    finishRun 2}
	-re ".*Permission denied, please try again.*" {
	    send_user "$expect_out(buffer)\nUnable to login to the OVM Manager using the admin password provided.\n"
	    send_user "Please verify that the password is correct and run the script again.\n\n"
	    finishRun 2}
	"password:" {
	    send_user "\nSending password...\n"; 
	    send "$Password\r";
	    exp_continue}
	-re ".*Host key verification failed.*\n" {
	    send_user "$expect_out(buffer)\n";
	    finishRun 2} 
	-re "(.*)\r" {exp_continue}
    }
    
    expect "*"
    return

}

proc NodeLogout {} {
    
    send "logout\r"
    return

}

## Capture the output from the CLI commands and print it out.
## If the command fails, sends unexpected output, or times out, 
## this is considered to be an error we can't recover from, so
## we exit.
proc validateCommandOutput {message} {
 
    global logfile
    global successMsg
    global failureMsg
    set timeout 890

    expect {
        $successMsg {send_user "$expect_out(buffer)\n"} 
        $failureMsg {send_user "$expect_out(buffer)\n"; finishRun 2} 
        timeout {
	    send_user "\nWatchdog Timeout: The $message command failed\n"
            send_user "to complete after more than 15 minutes.  The OVM CLI terminates\n"
	    send_user "idle connections after 15 minutes, and therefore the script has\n"
	    send_user "been terminated to avoid further failures.\n\n"
	    send_user "Please refer to $logfile for additional details.\n\n";
            finishRun 4
	}
    }

    expect "*"
}

## Capture the output from the CLI commands, and print it out.
## No verification of success or failure is done in this function.
proc showCommandOutput {message} {

    global logfile
    global successMsg
    global failureMsg
    set timeout 890
        
    expect {
        $successMsg {send_user "$expect_out(buffer)\n"} 
        $failureMsg {send_user "$expect_out(buffer)\n"} 
	timeout { 
	    send_user "\nWatchdog Timeout: The $message command failed\n"
            send_user "to complete after more than 15 minutes.  The OVM CLI terminates\n"
	    send_user "idle connections after 15 minutes, and therefore the script has\n"
	    send_user "been terminated to avoid further failures.\n\n"
	    send_user "Please refer to $logfile for additional details.\n\n";
            finishRun 4
	}
    }
    
    expect "*"
}


proc promptMe {prompt verify echo} {

    set timeout 800
    set userinput ""
    set userinput2 ""
    set mismatch "True"
    set extra ""

    ## Since all of the output is written to log files, we need
    ## turn off terminal echoing when we are prompting for 
    ## passwords.  
    if {$echo == "False"} {
	stty -echo echonl
    }

    while {$mismatch == "True"} {
	send_user "\n\n$prompt: "
	expect_user {
	    -re (.*)\n {set userinput $expect_out(1,string)}
	    timeout {
		send_error "The script has timed out after waiting 15 minutes for user input.\n"
		send_error "Terminating.\n"
		finishRun 4
	    }
	}

	## Some input we don't need to verify for correctness
	if {$verify == "True"} {
	    send_user "$prompt (confirm): "
	    expect_user {
		-re (.*)\n {set userinput2 $expect_out(1,string)}
		timeout {
		    send_error "\nThe script has timed out after waiting 15 minutes for user input.\n"
		    send_error "Terminating.\n"
		    finishRun 4
		}
	    }

	    if {$userinput == $userinput2} {
		set mismatch "False"
	    } else {
		send_error "The passwords did not match!\n"
		set mismatch "True"
	    }

	} else {
	    set mismatch "False"
	}
    }

    ## If we turned off echoing above, turn it back on....
    if {$echo == "False"} {
	stty sane
    }

    return $userinput
}

proc hasCHAPSupport {sanserver} {

    set hasCHAP "False"
    set done "False"
    set timeout 900
    
    
    while {$done == "False"} {
	send_user "Does $sanserver support CHAP Authentication? \[yes\|no\]: "
	expect_user {
	    "yes" {
		set hasCHAP "True"
		set done "True"
	    }
	    "no" { 
		set done "True"
	    }
	    -re "(.*)\n" {
		send_user "Invalid input: $expect_out(1,string)\n"
	    }
	    timeout {
		send_error "The script has timed out after waiting 15 minutes for user input.\n"
		send_error "Terminating.\n"
		set done "True"
		finishRun 4
	    }
	}
    }

    expect "*"
    return $hasCHAP
}


### When using the Oracle Generic SCSI plugin, "physical disks" are assigned
### an arbitrary name like "NETAPP (1)", and that name isn't guaranteed to 
### to be mapped to the same LUN every time the server to which it is mapped
### is discovered.  
###
### When using a Vendor Specific plugin, the physical disk names match the
### name of the LUN on the Storage Array.
###
### Therefore, it isn't possible to guarantee that if a user tells the script 
### the name of the mapped LUNs, that we'll find the right one when we need it.  
###
### In order to overcome this, we need to look at each of the servers after
### they are discovered, and look at each of the physical disks that they
### have attached.
proc discoverStorage {findMax verify server1 server2 slist} {

    array set myArray $slist

    ## The findSharedDisk function is expecting
    ## a list that can be converted into an array 
    ## to be passed in.  In order to force the
    ## lists returned by getDisks to conform to
    ## what is expected, we need to convert the 
    ## returned lists to arrays, and then combine
    ## the two arrays into one.
    array set diskList [getDisks $server1 $slist]
    array set diskList2 [getDisks $server2 $slist]

    set len [array size diskList]
    set len2 [array size diskList2]

    for {set i 0} {$i < $len2} {incr i 1} {
	set diskList($len) $diskList2($i)
	incr len 1
    }   

    ## Pool FS and Repo disks must be shared, so look for the
    ## disks which are mapped to both servers....
    array set mySharedDisks [findSharedDisks $verify [array get diskList]]
    set numShared [array size mySharedDisks]

        
    ## Here we're keeping track of each server's shared disks
    ## so that we can use them later...
    if {$numShared == 0} {
	send_user "Unable to find any disks which are mapped to both servers.\n"
	send_user "Exiting.\n"
	finishRun 2
    }


    if {$findMax == "True"} {
	### now we know which disks are shared, we just need to
	### find the biggest one, which will be used for the
	### repository, and one that is at least 12G or bigger
	### to use for the poolfs.
	send_user "\n\nFound $numShared disks which are mapped to both servers."
	send_user "  Determining\nwhich of those to use for the Pool Filesystem "
	send_user "and Repository.\n\nThis will take a moment...\n"

	determineMax [array get mySharedDisks]
    }

}


## Given a server, and then a list containing information
## about it; find all the Physical Disks associated with 
## that server.
proc getDisks {server slist} {
    global testStep
    global send_human
    global failureMsg
    global prompt

    array set myArray $slist
    array set diskList {}
    set timeout 600
    set i 0
 
    send_user "\n## [incr testStep 1]. Finding LUNs mapped to $myArray($server,name)...\n"
    send -h "show server id=$myArray($server,id)\r"
    sleep 5
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer); 
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1$output2\n\n";
	    finishRun 2}
	-re "Physical Disk (.*?) = (.*?) .*?\n\r" {
	    append dn $expect_out(1,string);
	    send_verbose "Found this disk: $expect_out(2,string)\n"
	    set diskList($i) $expect_out(2,string);
	    incr i 1;
	    exp_continue}
	-re "(.*)$prompt" {}
	timeout {
	    send_user "Unexpected error while trying to find disks\n"
	    finishRun 2}
    }
    
    return [array get diskList]
}

##  Given a list of Physical Disk IDs, determine which are
##  show up multiple times in the list (indicating that they
##  are shared).
proc findSharedDisks {verify list1} {
    
    array set myDisks $list1
    array set tempDisks {}
    array set shared {}
    set sd 0
    set nsd 0
    set count 1
    set disk 1
    set x [array size myDisks]

    ## First, find the shared disks
    for {set i 0} {$i < $x} {incr i 1} {
	if {$i > 0} {
	    if {[info exists tempDisks($myDisks($i),count)] == 1} { 
		set tempDisks($myDisks($i),count) [incr tempDisks($myDisks($i),count) 1]
		set shared($sd) $myDisks($i)
		incr sd 1
	    } else {
		set tempDisks($myDisks($i),count) 1
	    }
	} else {
	    set tempDisks($myDisks($i),count) 1
	}
    }
    
    return [array get shared]
}

## Given a list of Physical Disks that are known to be shared
## between two servers, determine the Max sized disk to use
## for a Repository, and find a suitably sized disk to use 
## for the Pool FS
proc determineMax {sharedDisks} {

    global myRepo
    global myPoolFS
    global sharedSpare
    global repoDiskName
    global poolfsDiskName
    global spareDiskName
    global failureMsg
    global testStep
    global prompt
    global send_human

    array set mySharedDisks $sharedDisks
    set numShared [array size mySharedDisks]
    set timeout 900
    set foundMax "False"
    set foundPFS "False"
    set foundSpare "False"
    set max 25
    set diskSize 0
    set dname ""
    set dlist []
    
    for {set i 0} {$i < $numShared} {incr i 1} {
	send_verbose "\n## [incr testStep 1]. Gathering information for PhysicalDisk id=$mySharedDisks($i)\n"
	send -h "show PhysicalDisk id=$mySharedDisks($i)\r"
	
	sleep 3
	
	expect {
	    $failureMsg {
		set output1 $expect_out(buffer); 
		expect -re "(.*)$prompt" {};
		set output2 $expect_out(1,string);
		send_user "$output1$output2\n\n";
		finishRun 2}
	    -re "Name = (.*?)\n\r" {
		set dname $expect_out(1,string)
		send_verbose "$dname = "
		lappend dlist $dname
		exp_continue}
	    -re "Size .*? = (.*?)\n\r" {
		set diskSize [expr {double($expect_out(1,string)) * 1}];
		send_verbose "$diskSize\n"
		exp_continue}
	    -re "(.*)$prompt" {}
	    timeout {
		send_user "Unexpected error while trying reading disk size info in the determineMax procedure\n"
		finishRun 2}
	}


	# The minimum size for the pool filesystem is 12G, but we're
	# expecting two disks sized 15 and 20 to be mapped. We want
	# to save the smaller one to use for a diskmap.  Leaving the
	# function general so that it can be reused with relative ease 
	# the next the test requirements change.
	if {$diskSize >= 12} {
	    ## We want the biggest disk possible for the repository,
	    ## so look for the largest available LUN
	    if {$diskSize > $max} {
		set max $diskSize
		set myRepo $mySharedDisks($i)
		set repoDiskName $dname
		set foundMax "True"
	    } else {
		## The pool filesystem disk doesn't need to be giant,
		## and we're asking vendors to set the size of the LUN
		## between 12 and 20G, so look for disks in that range
		## for the pool
		if {$diskSize >= 12 && $diskSize <= 19} {
		    set myPoolFS $mySharedDisks($i)
		    set poolSize $diskSize
		    set poolfsDiskName $dname
		    set foundPFS "True"
		}
	    }
	}

	## Now we need to find a shared disk to use for the VMs
	## if this disk is neither Max nor PFS, we can use it as
	## the spare....	
	if {$mySharedDisks($i) != $myRepo && $mySharedDisks($i) != $myPoolFS} {
	    set sharedSpare $mySharedDisks($i)
	    set spareDiskName $dname
	    set foundSpare "True"
	}

    }

    ## The spare got passed us, but there should be 
    ## a minimum of 3 shared disks to even get to this
    ## function, so there should be one available
    if {$foundSpare == "False"} {

	## no need to iterate through two lists, just
	## find the right id, then pull the name
	## from dname with the index number...
	for {set i 0} {$i < $numShared} {incr i 1} {
	    if {$mySharedDisks($i) != $myRepo && $mySharedDisks($i) != $myPoolFS} {
		set sharedSpare $mySharedDisks($i)
		set spareDiskName [lindex $dname $i]
		set $foundSpare "True"
	    }
	}
    }

    ## Make sure we actually have large enough disks for the 
    ## Pool FS and Repository...
    if {$foundMax == "False" || $foundPFS == "False"} {
	send_user "Unable to find two LUNs that were large enough to be\n"
	send_user "used for the Repository and Pool FS."
	finishRun 2
    }

    if {$foundSpare == "False"} {
	send_user "Unable to find a LUN to use as a disk on the VM.\n"
	send_user "This will prevent other test cases from succeeding.\n"
	finishRun 2
    }
}

## Given a Physical Disk name, and a Server ID, verify
## that the disk is mapped to the server.
proc verifyDiskMapping {diskname server} {

    global failureMsg
    global send_human
    global testStep

    set timeout 900
    set present "False"
    set diskList []

    send_verbose "\n## [incr testStep 1]. Verifying the presence or absence of $diskname on $server...\n"
    send -h "show server name=$server\r"
    sleep 4
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer);
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    finishRun 2}
	-re "Physical Disk .*? = .*?  .(\[A-Za-z0-9\-]*).\n\r" {
	    lappend diskList $expect_out(1,string)
	    send_verbose "Found this disk: $expect_out(1,string)\n"
	    exp_continue}
	-re ".*?OVM> " {}
	timeout {
	    send_user "Encountered unexpected error or output while verifying disk presence\n" 
	    finishRun 2}
    }

    if {[lsearch $diskList $diskname] >= 0} {
	set present "True" 
    }

    return $present
}

## With the generic plugin, the CLI doesn't update the disk list
## in the same way as when a vendor plugin is used.  LUNs
## that have been unmapped are still displayed in the disk
## list, and the only way to really know that the LUN
## is no longer mapped is to look at the events for the 
## LUN in question.
proc verifyDiskMapGeneric {diskname} {

    global failureMsg
    global send_human
    global testStep
    global prompt

    set timeout 900
    set present "False"  

    ## We need to look at the last event for the LUN in question.
    send_verbose "\n## [incr testStep 1]. Verifying the status of disk: $diskname\n"
    send -h "getEvents PhysicalDisk id=$diskname type=All amount=1\r"
    sleep 4
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer);
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    finishRun 2}
	-re ".*?type:StorageDeviceOfflineEvent.*?\n\r" {
	    send_user "Disk is offline or missing\n"
	    set present "Unmapped"
	    exp_continue
	}
	-re ".*?type:StorageDeviceUpEvent.*?\n\r" {
	    send_user "Disk is online and present!\n";
	    set present "Mapped"
	    exp_continue
	}
	-re ".*?type:CreatedEvent.*?\n\r" {
	    send_user "Disk was just mapped for the first time!\n"
	    set present "Created"
	    exp_continue
	}
	-re ".*$prompt" {}
    }
    
    expect "*"
    return $present
    
}


## For the map and unmap tests, the initial state
## must be that there are no LUNs mapped to the servers.
## Verify this is true, and if yes, we can continue
proc verifyInitialConfig {server1 server2 slist} {

    array set myArray $slist
    set serverlist []
    lappend serverlist $server1
    lappend serverlist $server2

    foreach server $serverlist {
	array set diskList [getDisks $server $slist]
    
	if {[array size diskList] > 0} {
	    send_user "\nDisk list for $myArray($server,name) was not empty.  Deterimining\n"
	    send_user "the number of local disks and LUNs.  This will take a moment...\n"

	    set length [array size diskList]
	    set lcount 0
	    
	    for {set i 0} {$i < $length} {incr i 1} {
		if {[isLocalDisk $diskList($i)] == "True"} {
		    incr lcount 1
		    sleep 5
		}
	    }

	   
	    set myArray($server,haslocal) $lcount	    
	    
	    if {$lcount == $length} {
		send_user "The extra disks appear to be local disks, not LUNs.\nContinuing.\n"
		set myArray($server,verified) "True"
	    } else {
		set myArray($server,verified) "False"
	    }
		

	} else {
	    set myArray($server,verified) "True"
	    set myArray($server,haslocal) 0	    
	}

	sleep 10
	array unset diskList
    }

    return [array get myArray]

}


## When we're verifying disks, we need to be able
## to differentiate between a localdisk, which we 
## don't care about, and a mapped LUN, which we do 
## care about.
proc isLocalDisk {diskname} {

    global failureMsg
    global send_human
    global prompt

    set timeout 300
    set isLocal "False"

    send -h "show physicaldisk id=$diskname\r"
    sleep 8
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer);
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    finishRun 2}
	-re "VolumeGroup = Local_Storage_Volume_Group.*?\n\r" {
	    set isLocal "True"
	}
	-re ".*$prompt" {}
	timeout {
	    send_user "Watchdog timeout while verifying local disk.\nExiting!\n"
	    finishRun 4
	}
    }

    expect "*"
    return $isLocal
}


proc verifyExpectedMaps {disklist expectedMap expectedUnmap sizelist} {

    set status "False"
    array set myDisks $disklist
    set length [array size myDisks]
    set unmap 0
    set map 0
    set sizes "True"

    for {set i 0} {$i < $length} {incr i 1} {
	
	if {[isLocalDisk $myDisks($i)] == "True"} {
	    incr map 1
	    continue
	}
	
	set status [verifyDiskMapGeneric $myDisks($i)]

	switch -- $status \
	    "Unmapped" {
		set unmap [incr unmap 1]
	    } "Mapped" {
		set map [incr map 1]
	    } "Created" {
		set map [incr map 1]
	    } default {
		send_user "Unknown disk status encountered. Unable to procede.\nTerminating.\n"
		finishRun 4
	    }

	set mySize [getDiskSize $myDisks($i)]
	
	if {[lsearch $sizelist $mySize] == -1} {
	    send_user "Unexpected disk size: $mySize!  Terminiating.\n"
	    return "False"
	}
    }

    if {$unmap != $expectedUnmap || $map != $expectedMap} {
	send_user "Expected $expectedMap LUNs to be mapped, and found $map.\n"
	send_user "Expected $expectedUnmap LUNs in the offline or warning state, and found $unmap.\n"
	send_user "LUNs are not mapped in accordance with expectations.\nTerminating.\n"
	return "False"
    } else {
	return "True"
    }
}

proc refreshPhysicalDisks {disklist} {

    global successMsg
    global failureMsg
    global send_human
    global testStep
    global prompt

    array set myDisks $disklist
    set length [array size myDisks]

    for {set i 0} {$i < $length} {incr i 1} {

	send_user "\n## [incr testStep 1]. Refreshing PhysicalDisk id=$myDisks($i)\n"
	if {[isLocalDisk $myDisks($i)] == "True"} {
	    send_verbose "Found local disk.  Skipping.\n"
	    continue
	}

	send -h "refresh physicaldisk id=$myDisks($i)\r"
	validateCommandOutput "refresh physicaldisk command"

    }

}

proc getDiskSize {diskname} {

    global failureMsg
    global send_human
    global testStep
    global prompt

    set mySize 0

    send_user "\n## [incr testStep 1]. Reading disk size information for disk id=$diskname\n"
    send -h "show physicaldisk id=$diskname\r"
    sleep 5
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer);
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    finishRun 2}
	-re "Size .*? = (.*?)\n\r" {
	    set mySize $expect_out(1,string)
	    exp_continue
	}
	-re ".*$prompt" {}
    }
    expect "*"

    ## The disk size is reported occasionally as a double, instead of int.
    ## but we have no way to tell the difference between a disk that is
    ## 5G and one that is 5.0G, but the tests looking at size will fail
    ## if the size reported as 5.0 when we're looking for 5, so eliminate 
    ## that failure by stripping the extraneous numbers after the decimal 
    ## point.  If the size doesn't match, it doesn't match, but decimals 
    ## shouldn't cause the test to fail
    set drop [string first "." $mySize]

    if {$drop == -1} {
	return  $mySize
    } else {
	return [string trimright [string range $mySize 0 $drop] "."]
    }
}


proc refreshAndVerifySize {diskname sizelist} {

    global successMsg
    global failureMsg
    global send_human
    global testStep
    global prompt

    set status "True"
    set initsize 0
    set finsize 0

    send_user "\n## [incr testStep 1]. Verifying LUN resize on LUN id=$diskname\n"

    if {[isLocalDisk $diskname] == "True"} {
	send_user "Viewing a local disk.\nSkipping.\n"
	return "Local"
    }

    set initsize [getDiskSize $diskname]

    send_user "Refreshing the LUN to see the changes....\n"
    send -h "refresh physicaldisk id=$diskname\r"
    validateCommandOutput "refresh physicaldisk command"

    send_user "\nWaiting 30 seconds for the changes to be propagated to the manager...\n"
    sleep 30

    set finsize [getDiskSize $diskname]

    if {[lsearch $sizelist $finsize] == -1} {
	send_user "Unexpected disk size reported for $diskname!\nTerminating.\n"
	finishRun 2
    } else {

	## Deal with the issue where there are multiple, same sized disks.
	## This state shouldn't happen if the disks are sized as expected
	## but there are times when the storage layer incorrectly reports
	## a disk multiple times, and that should be caught.  Here, we 
	## remove the size from the size list once we've found a matching 
	## disk. This will cause a failure if we see another disk with the 
	## same size.
	#set [lsearch -inline -all -not -exact $mylist $finsize]

    	if {$finsize > $initsize} {
	   send_user "Disk was resized as expected!  LUN grew from $initsize to $finsize GB.\n"
	   set status "True"
	} else {
	    send_user "Disk was sized as expected!  LUN size started at $initsize GB\n"
	    send_user "and after verification, still reported $finsize GB!\n"
	    set status "False"	
	}
    }

    return $status
}


## The CLI keeps all LUNs (both mapped and unmapped) in the disklist
## so in order to keep track of the disks that are expected to be
## associated with each server, we need to keep the disk list clean.
## This function should only be called after having explicitly 
## unmapped LUNs.
proc deleteLUNs {disklist} {

    global testStep

    array set myDisks $disklist
    set length [array size myDisks]
    set dcount 0

    ## We can ignore local disks, and those that are
    ## marked as mapped.
    send_user "Searching for unmapped disks...\n"
    for {set i 0} {$i < $length} {incr i 1} {
	if {[isLocalDisk $myDisks($i)] == "True"} {
	    send_verbose "Found a local disk.  Skipping.\n"
	    continue
	}
	
	if {[verifyDiskMapGeneric $myDisks($i)] == "Unmapped"} {
	    send_verbose "Found an unmapped LUN.\n"
	    send_user "\n## [incr testStep 1]. Deleting the unmapped LUN.\n"
	    send -h "delete PhysicalDisk id=$myDisks($i)\r"
	    validateCommandOutput "delete physicaldisk command"
	    incr dcount 1
	}
    }

    return $dcount
}

## Attempt to resize (grow and shrink) Physical Disks, using the new disk
## passed in to the function.  This function returns true if the the
## resize was successful.
proc resizeDisks {diskname newsize} {

    global testStep
    global send_human
    global successMsg
    global failureMsg
    global prompt
    
    set timeout 600
    set resize "True"
    
    send_user "\n## [incr testStep 1]. Resizing LUN $diskname, setting new size at $newsize GB\n"
    send "edit physicaldisk name=$diskname size=$newsize\r"

    sleep 5
    
    expect {
	$successMsg {
	    send_user "$expect_out(buffer)\n"; 
	    set resize "True"
	    exp_continue} 
	$failureMsg {
	    send_user "$expect_out(buffer)\n";  
	    set resize "False"; 
	    exp_continue}
	-re "(.*)$prompt" {}
	timeout { 
	    send_user "OVMM Response Timeout: An unexpected error has occurred while executing the disk resize:\n"
	    send_user "Please refer to $logfile for additional details.\n\n";
	    set resize "Unknown"}
    }
    
    return $resize
}


## Given an IP address (or subnet), and a Network Role,
## create a new network.  If the network has already been 
## defined, this function will attempt to add the new Role 
## to the existing network.
proc createNetwork {myIP myRole} {

    global testStep
    global send_human
    global failureMsg
    global prompt

    set timeout 600
    set myNetworks []

    send -h "list network\r"
    sleep 4
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer);
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    finishRun 2}
	-re "id:.*? name:(.*?)\n\r" {
	    send_verbose "Found this network: $expect_out(1,string)\n"
	    lappend myNetworks $expect_out(1,string); 
	    exp_continue}
	-re "(.*)$prompt" {}
	timeout {
	    send_user "An unexpected error occurred while reading Network information.\n"
	    finishRun 2}
    }


    if { [lsearch $myNetworks $myIP] >= 0} {
	send_verbose "\nFound an existing Network named $myIP;\n"
	send_verbose "Attempting to update $myIP with role=$myRole.\n"
	updateNetworkRoles $myIP $myRole
    } else {
	send_user "\n## [incr testStep 1]. Creating the $myRole network: $myIP\n" 
	send -h "create network name='$myIP' roles=$myRole\r"
	sleep 3
	validateCommandOutput "create network command"
    }
    
}

## Update an existing Network with additional Roles.
proc updateNetworkRoles {paramIP paramRole} {

    global testStep 
    global failureMsg
    global send_human
    global prompt

    set timeout 600
    set myRoles []
    set roles ""
    set alreadySet 0
    
    send_verbose "Gathering information about existing Roles for Network: $paramIP\n"
    send -h "show network name=$paramIP\r"
    sleep 4
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer);
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1$output2\n\n";
	    finishRun 2}
	-re "Role \[0-9] = (.*?)\n\r" {
	    switch -- $expect_out(1,string) \
		"Server Management" {
		    lappend myRoles "MANAGEMENT"
		} "Live Migrate" {
		    lappend myRoles "LIVE_MIGRATE"
		} "Cluster Heartbeat" {
		    lappend myRoles "CLUSTER_HEARTBEAT"
		} "Virtual Machine" {
		    lappend myRoles "VIRTUAL_MACHINE"
		} "Storage" {
		    lappend myRoles "STORAGE"
		} default {
		    send_user "Unknown network role encountered... exiting\n"
		}
	    exp_continue}
	-re "(.*)$prompt" {}
	timeout {
	    send_user "An unexpected error occurred while viewing $paramIP\n"
	    finishRun 2}
    }

    ## Verify that the role hasn't already been assigned to this network
    ## and if not, set it.
    if {[lsearch $myRoles $paramRole] == -1} {
	send_user "\n## [incr testStep 1]. Adding the role $paramRole to the $paramIP network...\n"
	lappend myRoles $paramRole
	set newRoles [join $myRoles ","] 
	send -h "edit network name=$paramIP roles=$newRoles\r"
	validateCommandOutput "edit network command"
    } else {
	send_verbose "The role $paramRole was already set for the $paramIP network\n"
    }

}

## Update an existing network with new ports.
proc addPorts {netmask network sinfoList} {

    global testStep
    global send_human
    global failureMsg
    global prompt

    array set myPorts $sinfoList
    set existingPorts []
    set timeout 600

    send_verbose "Gathering port information for Network: $network...\n"
    send -h "show network name=$network\r"

    sleep 5

    expect { 
	$failureMsg {
	    set output1 $expect_out(buffer); 
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    finishRun 2}
	-re "Port \[0-9]*? = (\[0-9a-f]*?) (.*?)\n\r" {
	    send_verbose "Found existing port $expect_out(1,string) = $expect_out(2,string)\n"
	    lappend existingPorts [string trim $expect_out(1,string)]
	    exp_continue}
	-re "(.*)$prompt" {}
	timeout {
	    send_user "An unexpected error has occurred while reading reading $network Network information.\n"
	    finishRun 2}
    }

    ## Verify whether the ports have already been added to the network, 
    ## and if not, add them in and set the correct values for the IP and Netmask.
    if {[lsearch $existingPorts "$myPorts(master,id)"] >= 0} {
	send_user "$myPorts(master,ip) has already been setup on $network.  Skipping.\n"
    } else {
	send_user "\n## [incr testStep 1]. Updating the $network network to use $myPorts(master,name).\n"
	send  "add port id=$myPorts(master,id) to network name=$network\r"
	validateCommandOutput "update storage network command"
	
	send_user "\n## [incr testStep 1]. Editing the port information for $myPorts(master,name) on the Storage Network\n"
	send "edit port id=$myPorts(master,id) addressType=staticIp ipAddress=$myPorts(master,ip) netMask=$netmask\r"
	validateCommandOutput "edit port command"
    }
    
    if {[lsearch $existingPorts $myPorts(slave,id)] >= 0} {
	send_user "$myPorts(slave,ip) has already been setup on $network.  Skipping.\n"
    } else {
	send_user "\n## [incr testStep 1]. Updating the $network network to use $myPorts(slave,name).\n"
	send "add port id=$myPorts(slave,id) to network name=$network\r"
	validateCommandOutput "update storage network command"
    
	send_user "\n## [incr testStep 1]. Editing the port information for $myPorts(slave,name) on the Storage Network\n"
	send "edit port id=$myPorts(slave,id) addressType=staticIp ipAddress=$myPorts(slave,ip) netMask=$netmask\r"
	validateCommandOutput "edit port command"
    }

}

proc createVNIC {vnicName network} {

    global testStep
    global send_human
    global failureMsg
    global prompt

    set timeout 600
    set myVNICs []

    send -h "show network name=$network\r"
    sleep 4
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer);
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    finishRun 2}
	-re "Vnic .*? =  (.*?) .(\[a-f0-9\:]).*?\n\r" {
	    send_verbose "Found this vNIC: $expect_out(1,string)\n"
	    lappend myVNICs $expect_out(1,string); 
	    exp_continue}
	-re "(.*)$prompt" {}
	timeout {
	    send_user "An unexpected error occurred while reading Network information.\n"
	    finishRun 2}
    }


    if { [lsearch $myVNICs $vnicName] >= 0} {
	send_verbose "\nFound an existing vNIC: $vnicName.\nContinuing."
    } else {
	send_user "\n## [incr testStep 1]. Creating vNIC \"$vnicName\" on the $network network\n"
	send  "create vnic name=$vnicName network=$network\r"
	validateCommandOutput "create vnic command"
    }

}

## We only want to add vNICs to VMs if they
## haven't been added automatically, to avoid
## issues that stem from having multiple
## live nics on the vm. 
proc addVnic {vnic vmname} {

    global send_human
    global prompt
    
    set timeout 300
    set found "False"

    send -h "show vm name=$vmname\r"
    sleep 3
    expect {
	-re "Vnic \[0-9]* = (.*?) \\\[(.*?)]\n\r" {
	    send_user "Found this vnic: $expect_out(2,string) on $vmname.  Skipping.\n"
	    set found "True"
	}
	-re "(.*)$prompt" {}
	timeout {send_user "Timeout occurred while attempting to view vNICs on $vmname!\n"; finishRun 4}
    }

    expect "*"

    if {$found == "False"} {
	send "add vnic name=$vnic to vm name=$vmname\r"
	validateCommandOutput "add vnic command"
    }

}

## Since it's hard to determine exactly how OVMM will display 
## the plugin name, we want to make sure we're always using 
## the name that is expected to avoid script failures.  
## 
## We can query the CLI to tell us what the names of the
## installed plugins are by running the 'create SanServer' 
## command. 
proc find_SCSI_Plugins {askUser type} {

    global testStep
    global send_human

    set pluginList []
    set allplugins ""    
    set myPlugin ""
    set mismatch "True"
    set timeout 900
    set andthis ""

    send_user "\nGathering the list of installed Storage Connect Plugins...\n"


    if {$type == "SCSI"} {
	send "create SanServer plugin=?\r"
    } else {
	send "create FileServer plugin=?\r"
    }
    sleep 5
    expect {
	-re "(.*?)\n(.*?)(OVM>.*)\n\r" { 
	    set output [string trim $expect_out(2,string)]
	    set allplugins [regsub -all -- "/" $output "//"] 
	    exp_continue
	}
	-re ".*OVM>" {}
	timeout {
	    send_user "Timeout received from OVM while attempting to view installed plugin data.\n"
	    send_user "Terminating.\n"
	    finishRun 4
	}
    }


    set pluginList [split $allplugins ","]

    ## If this is true, we're using a vendor supplied plugin
    ## so we want to ask the user which plugin to use.
    ## If it's not set, then we know we're just doing the
    ## generic plugin tests, and we'll just look for the 
    ## name of the generic plugin.
    if {$askUser == "True"} {
	
	set index 0
	set myVal ""
	set myPrompt "This is the complete list of Storage Connect plugins found by OVM.\n"

	foreach plugin $pluginList {   
	    append myPrompt "$index. $plugin\n"
	    incr index 1
	}

	append myPrompt "Please enter the number corresponding to the plugin\nname to be used in today's certification tests: "
	

	while {$mismatch == "True"} {
	    send_user "\n\n$myPrompt"
	    expect_user {
		-re "(\[0-9]+)\n" {
		    set userinput $expect_out(1,string);
		    set mismatch "False"
		}
		-re "(.*)\n" {
		    send_user "You entered an invalid choice.\n"
		}
		timeout {
		    send_error "The script has timed out after waiting 30 minutes for user input.\n"
		    send_error "Terminating.\n"
		    finishRun 4
		}
	    }
	}

	set myPlugin [lindex $pluginList $userinput]


    } else {
	foreach plugin $pluginList { 
	    if {[string match *eneric* $plugin]} {
		set myPlugin $plugin
		break
	    }
	}
    }

    return $myPlugin
}

## Find storage initiators on a server, depending on protocol type.
proc getInitiators {itype serverName} {

    global testStep
    global send_human
    global failureMsg
    global prompt
    
    set timeout 900
    set match_max 10000
    set initiatorList []
    
    send_verbose "Gathering initiator information from $serverName....\n"
    
    if {$itype == "iscsi"} {
	send -h "show server name=$serverName\r"
	sleep 5
	expect {
	    $failureMsg {
		set output1 $expect_out(buffer); 
		expect -re "(.*)$prompt" {};
		set output2 $expect_out(1,string);
		send_user "$output1$output2\n\n";
		finishRun 2}
	    -re "Storage Initiator .*? (iqn\..*?)\n\r" {
		lappend initiatorList [string trim $expect_out(1,string)];
		send_verbose "Found initiator: $expect_out(1,string)\n" 
		exp_continue}
	    -re "(.*)$prompt" {}
	    timeout { 
		send_user "An unexpected error has occurred while reading iSCSI Initiator information.\n"
		finishRun 2}
	}
    } else {
	send -h "show server name=$serverName\r"
	sleep 5
	expect {
	    $failureMsg {
		set output1 $expect_out(buffer);
		expect -re "(.*)$prompt" {};
		set output2 $expect_out(1,string);
		send_user "$output1$output2\n\n";
		finishRun 2}
	    -re "Storage Initiator .*? (0x.*?) .*?\n\r" {
		lappend initiatorList [string trim $expect_out(1,string)];
		send_verbose "Found initiator: $expect_out(1,string)\n" 
		exp_continue}
	    -re "(.*)$prompt" {}
	    timeout {
		send_user "An unexpected error has occurred while reading FC Initiator information.\n"
		finishRun 2}
	}
    }
	    
    sleep 8
    return $initiatorList
}


## Add storage initiators to an Access Group on the Storage Array
proc addInitiators {itype servername accessGroup} {

    global testStep
    global send_human

    set initiatorList [getInitiators $itype $servername]
    send_user "\n## [incr testStep 1]. Adding the $itype initiators from $servername to $accessGroup.\n"

    foreach initiator $initiatorList {	
	sleep 4
	send_verbose "Adding $initiator to $accessGroup.\n"
	send -h "add StorageInitiator id='$initiator' to AccessGroup name='$accessGroup'\r"
	validateCommandOutput "add StorageInitiator command"
	send_user "\n"
    }
}

proc findAccessGroups {} {

    global testStep
    global send_human
    global failureMsg
    global prompt

    set exitcode "False"
    
    send -h "list AccessGroup\r"
    sleep 5
    expect {  
        $failureMsg {
            set output1 $expect_out(buffer); 
            expect -re "(.*)$prompt" {};
            set output2 $expect_out(1,string);
            send_user "$output1\n$output2\n\n";
            set exitcode "False"}
        -re ".*None*" {
            send_verbose "Found no Access Groups...\n"
            set exitcode "False"}
        -re "id:(.*?) name:(.*?)\n\r" { 
            send_verbose "Found Access Group: $expect_out(2,string)\n"
            set agName $expect_out(2,string)
	    set exitcode "True"}
        -re "(.*)$prompt" {
	    set exitcode "True"}
    }
    
    expect "*"

    if {$exitcode == "False"} {
	send_user "An unexpected error has occurred while viewing Access Group information,"
        finishRun 2
    }

    return $agName
}

## Find a list of all of the servers which have been discovered
## by the Manager.
proc getServerIDs {} {

    global send_human
    global failureMsg
    global prompt
    set timeout 600

    array set myArray {}
    set x 0
    
    # Clear the expect buffer
    expect "*"

    # Get the name and id for the servers which have
    # been discovered by the manager.  We will need 
    # the IDs mapped to IP addresses to know which
    # disks are mapped, resources associated with, 
    # etc. to which ID.
    send -h "list server\r"
    sleep 4
    expect {
        $failureMsg {
            set output1 $expect_out(buffer);
            expect -re "(.*)$prompt" {};
            set output2 $expect_out(1,string);
            finishRun 2}
        -re "id:(.*?) name:(.*?)\n\r" {
            set myArray($x,id) [string trim $expect_out(1,string)];
            set myArray($x,name) [string trim $expect_out(2,string)];
            incr x 1;
            exp_continue}
        -re "(.*)$prompt" {}
        timeout {send_user "Unexpected error while viewing server info in proc getServerIDs\n"}
    }

    return [array get myArray]

}

### The assumption should be that the two servers being used
### for this testing are the only servers that have been discovered,
### but in case that's not true, we should verify that we're only
### doing anything with the servers we are specifically supposed
### to know about....
proc verifyServers {server1 server2 port vm_port slist} {

    global send_human
    global failureMsg
    global prompt

    array set knownServer $slist
    array set myServers {}
    array set ethPorts {}
    array set bondPorts {}

    set x [array size knownServer]
    set myIP ""
    set myPort $port
    set myVm_Port $vm_port
    set lame ""

    for {set i 0} {$i < $x} {incr i 1} {

	### The length of the array will be weird because of the way
	### the elements are composed. Verify that it exists....
	if {[info exists knownServer($i,id)]} {
	    send_verbose "Gathering information from Server: id=$knownServer($i,id)\n"
	    send -h "show server id=$knownServer($i,id)\r"
	    sleep 5
	    expect {
		$failureMsg {
		    set output1 $expect_out(buffer);
		    expect -re "(.*)$prompt" {};
		    set output2 $expect_out(1,string);
		    send_user "$output1\n$output2\n\n";
		    finishRun 2}	  
		-re "IP Address = (.*?)\n\r" {
		    set myIP $expect_out(1,string)
		    exp_continue}
		-re "Ethernet Port \[0-9] = (.*?) .(\[a-z]*\[0-9]) on .*?\n\r" {
		    set ethPorts($expect_out(2,string)) [string trim $expect_out(1,string)]
		    exp_continue}
		-re "Bond Port \[0-9] = (.*?) .(\[a-z]*\[0-9]) on .*?\n\r" {
		    set bondPorts($expect_out(2,string)) [string trim $expect_out(1,string)]
		    exp_continue}
		-re "(.*)$prompt" {}
		timeout {finishRun 2}
	    }
	    	    
	    switch -- $myIP \
		$server1 {
		    send_verbose "Collecting details for $knownServer($i,name)\n"
		    set myServers($myIP,id) $knownServer($i,id)
		    set myServers($myIP,name) $knownServer($i,name)
		    set myServers($myIP,verified) "False"
		    set myServers($myIP,haslocal) 0
		    if {[info exists ethPorts($port)]} {
			set myServers($myIP,port) $ethPorts($port)
		    }		    
		    if {[info exists ethPorts($vm_port)]} {
			set myServers($myIP,vm_port) $ethPorts($vm_port)
		    } 
		    if {[info exists bondPorts($port)]} {
			set myServers($myIP,port) $bondPorts($port)
		    }
		    if {[info exists bondPorts($vm_port)]} {
			set myServers($myIP,vm_port) $bondPorts($vm_port)
		    }
		} $server2 {
		    send_verbose "Collecting details for $knownServer($i,name)\n"
		    set myServers($myIP,id) $knownServer($i,id)
		    set myServers($myIP,name) $knownServer($i,name)
		    set myServers($myIP,verified) "False"
		    set myServers($myIP,haslocal) 0
		    if {[info exists ethPorts($port)]} {
			set myServers($myIP,port) $ethPorts($port)
		    }
		    if {[info exists ethPorts($vm_port)]} {
			set myServers($myIP,vm_port) $ethPorts($vm_port)
		    }
		    if {[info exists bondPorts($port)]} {
			set myServers($myIP,port) $bondPorts($port)
		    }
		    if {[info exists bondPorts($vm_port)]} {
			set myServers($myIP,vm_port) $bondPorts($vm_port)
		    }
		} default {
		    send_verbose "Found this non-matching IP: $myIP.  Skipping.\n"
		}
	    
	    unset ethPorts
	    unset bondPorts
	    array set ethPorts {}
	    array set bondPorts {}
	    set myIP ""
	    set lame ""
	    set myPort $port
	    set myVm_Port $vm_port
	    
	}
    }

    return [array get myServers]
}

## Determine which server a VM is associated with.  This function
## is used to determine where (which server) to migrate VMs
proc findSource {vmName} {

    global testStep
    global send_human
    global failureMsg
    global prompt
    set timeout 600

    set myID ""

    send_user "\n## [incr testStep 1]. Determining on which server $vmName is currently running...\n"
    send -h "show vm name=$vmName\r"
    sleep 3
    expect {
	$failureMsg {
	    set output1 $expect_out(buffer); 
	    expect -re "(.*)$prompt" {};
	    set output2 $expect_out(1,string);
	    send_user "$output1\n$output2\n\n";
	    set myID "False"} 
	-re "Server = (.*?)  .*?\n\r" {
	    set myID [string trim $expect_out(1,string)]
	    send_verbose "Found the Source ID: $expect_out(1,string)\n"
	    exp_continue}
	-re "(.*)$prompt" {}
	timeout { 
	    send_user "An unexpected error occurred while attempting to view VM information.\n"
	    set myID "False"
	}
    }
    return $myID
}


## This bit of code was being reused all over the place, 
## so we're just making it into a function
proc verifyResize {diskList origsizes newsizes} {

    array set myDisks $diskList
    array set original $origsizes

    set rcount 0

    set length [array size myDisks]
    for {set i 0} {$i < $length} {incr i 1} {

	if {[isLocalDisk $myDisks($i)] == "True"} {
	    continue
	}

	set thisSize [getDiskSize $myDisks($i)]
	
	if {[lsearch $newsizes $thisSize] == -1} {
	    send_user "Disk was unexpectedly sized at $thisSize.\nTerminating.\n"
	    finishRun 2
	}
	
	if {$thisSize > $original($i)} {
	    incr rcount 1
	}
    } 

    return $rcount
}


## Depending on how vendors have their storage arrays and OVS servers
## configured, it may be that they need to modify the Server configuration
## (i.e., the use of different initiator names, etc.) prior to the
## execution of the CHAP Authentication tests.  This function just
## prompts the user to make any necessary changes, then pauses until
## they are ready to begin again.
proc setupCHAP {} {

    set timeout 900

    send_user "\n\nPlease make any necessary configuration changes to your Storage Array\n"
    send_user "or OVS Servers, at this time for CHAP Authentication testing.  Once you\n"
    send_user "are ready to resume the tests, type 'resume' at the prompt.  To quit, type\n"
    send_user "'quit'.\n\nHCL> "
    expect_user {
	-re "(.*?)quit\n" { 
	    send_user "User terminated script.  Exiting.\n"
	    finishRun 2 
	} 
	-re "(.*?)resume\n" {
	    send_user "Resuming iSCSI certification...\n"
	}
	-re "(.*?)\n" {send_user "Please enter either 'resume' or 'quit'.\n"; send_user "HCL> "; send " \r"; exp_continue}
	timeout {
	    send_error "The script has timed out after waiting 15 minutes for user input.\n"
	    send_error "Terminating.\n"
	    finishRun 4
	    }
	}

    expect "*"

    return
}

## The 
proc findClonedLUN {vmname diskmap} {

    global testStep
    global send_human
    global successMsg
    global failureMsg
    global prompt

    set timeout 600
    set mapID ""
    set diskID ""

    send "show VM name=$vmname\r"
    sleep 5
    expect {
	-re "VmDiskMapping (.*?) = (.*?)\n\r" {
	    set myMap $expect_out(1,string)
	    set myID $expect_out(2,string)
	    send_verbose "Found this diskmap: VmDiskMapping $myMap = $myID\n"
	    if {$diskmap == $myMap} {
		set mapID $myID
	    }
	    exp_continue
	}
	-re "(.*)$prompt" {}
    }

    ## Now we know the diskmap id, and from there we
    ## can find the disk id...
    send "show VmDiskMapping id=$mapID\r"
    sleep 5
    expect {
	-re "Virtual Disk Id = (.*?) .*?\n\r" {
	    set diskID $expect_out(1,string)
	    send_verbose "This disk is the cloned LUN: $diskID\n"
	    exp_continue
	}
	-re "(.*)$prompt" {}

    }

    expect "*"
    return $diskID
}

## Part of the clean up functionality.  Given the names of servers.
## find their IDs and delete them.
proc deleteServers {server1 server2} {

    global testStep
    global send_human
    global successMsg
    global failureMsg
    global prompt
    set timeout 900

    set exitcode "True"

    set slist [getServerIDs]
    array set myServers [verifyServers $server1 $server2 eth0 eth0 $slist]

    # Clear the expect buffer
    expect "*"

    if {[info exists myServers($server1,name)]} {
        send_user "\n## [incr testStep 1]. Deleting $myServers($server1,name)...\n"
        send -h "delete server id=$myServers($server1,id)\r"
	sleep 5
    	expect {
	    $successMsg {
		send_user "$expect_out(buffer)\n"; 
		set exitcode "True"
		exp_continue} 
	    $failureMsg {
		send_user "$expect_out(buffer)\n";  
		set exitcode "False"; 
		exp_continue}
	    -re "(.*)$prompt" {}
	    timeout { 
		send_user "OVMM Response Timeout: An unexpected error has occurred while executing the delete server command:\n"
		send_user "Please refer to $logfile for additional details.\n\n";
		set exitcode "False"}
	}
    } else {
	set exitcode "None"
    }

    if {[info exists myServers($server2,name)]} {
        send_user "\n## [incr testStep 1]. Deleting $myServers($server2,name)...\n"
        send -h "delete server id=$myServers($server2,id)\r"
	sleep 5
	expect {
	    $successMsg {
		send_user "$expect_out(buffer)\n"; 
		set exitcode "True"
		exp_continue} 
	    $failureMsg {
		send_user "$expect_out(buffer)\n";  
		set exitcode "False"; 
		exp_continue}
	    -re "(.*)$prompt" {}
	    timeout { 
		send_user "OVMM Response Timeout: An unexpected error has occurred while executing the delete server command:\n"
		send_user "Please refer to $logfile for additional details.\n\n";
		set exitcode "False"}
	}
    } else {
	set exitcode "None"
    }

    return $exitcode
}

## Given a list of VM IDs, stop and delete all VMs. 
proc deleteVM {vmList} {

    global testStep
    global send_human

    array set myVMs [getList VM]

    set found 0

    if {[array size myVMs] == 0} {
	return "None"
    }

    foreach vm $vmList {
	if {[info exists myVMs($vm)]} {
	    incr found 1
	    send_user "\n## [incr testStep 1]. Attempting to stop $vm, then deleting....\n"
	    send -h "stop vm id=$myVMs($vm)\r"
	    showCommandOutput "stop vm command"

	    send_user "\n"

	    sleep 3
	    send -h "delete vm id=$myVMs($vm)\r"
	    validateCommandOutput "delete vm command"
	    send_user "\n\n"
	}
    }

    if {$found == 0} {
	return "None"
    } else {
	return "True"
    }

}

## Given a list of Vnic IDs, delete those that exist. 
proc deleteVNICs {vnicList} {

    global testStep
    global send_human

    array set myVNICs [getList vnic]

    set found 0

    if {[array size myVNICs] == 0} {
	return "None"
    }

    foreach vnic $vnicList {
	if {[info exists myVNICs($vnic)]} {
	    incr found 1
	    send_user "\n## [incr testStep 1]. Deleting $vnic\n"
	    send -h "delete vnic id=$myVNICs($vnic)\r"
	    sleep 4
	    validateCommandOutput "delete vnic command"
	    send_user "\n\n"
	}
    }

    if {$found == 0} {
	return "None"
    } else {
	return "True"
    }

}

proc deleteNetwork {network} {

    global testStep
    global send_human
    
    array set myNetworks [getList Network]

    if {[array size myNetworks] == 0} {
	return "None"
    }

    if {[info exists myNetworks($network)]} {
	send_user "\n## [incr testStep 1]. Deleting $network\n"
	send -h "delete network id=$myNetworks($network)\r"
	validateCommandOutput "delete $network Network command"
	send_user "\n\n"
	return "True"
    } else {
	return "None"
    }	
}

## Make sure the SAN Server has been defined before trying to delete it
proc deleteSANServer {SAN_ServerName} {

    global testStep
    global send_human
    
    array set mySANServers [getList SanServer]

    if {[array size mySANServers] == 0} {
	return "None"
    }

    if {[info exists mySANServers($SAN_ServerName)]} {
	send_user "\n## [incr testStep 1]. Deleting $SAN_ServerName\n"
	send -h "delete SanServer id=$mySANServers($SAN_ServerName)\r"
	validateCommandOutput "delete SanServer command"
	send_user "\n\n"
	return "True"
    } else {
	return "None"
    }
}

## Make sure the File Server has been defined before trying to delete it
proc deleteFileServer {File_ServerName} {

    global testStep
    global send_human
    
    array set myFileServers [getList FileServer]

    if {[array size myFileServers] == 0} {
	return "None"
    }

    if {[info exists myFileServers($File_ServerName)]} {
	send_user "\n## [incr testStep 1]. Deleting $File_ServerName\n"
	send -h "delete FileServer id=$myFileServers($File_ServerName)\r"
	validateCommandOutput "delete FileServer command"
	send_user "\n\n"
	return "True"
    } else {
	return "None"
    }
}

proc deleteStragglerLUNs {} {

    global send_human
    global failureMsg
    global testStep
    global prompt

    set timeout 600
    set myLeftoverLUNs []

    expect "*"

    send_user "\n## [incr testStep 1]. Getting the list of PhysicalDisks....\n"
    send "list PhysicalDisk\r"
    sleep 5
    expect {  
        $failureMsg {
            set output1 $expect_out(buffer); 
            expect -re "(.*)$prompt" {};
            set output2 $expect_out(1,string);
            send_user "$output1\n$output2\n\n"}
        -re ".*None*" {
            send_user "Found no PhysicalDisks...\n"}
        -re "id:(.*?) name:(.*?)\n\r" { 
            send_user "Found PhysicalDisk: $expect_out(2,string)\n"
            lappend myLeftoverLUNs [string trim $expect_out(1,string)]
            exp_continue}
        -re "(.*)$prompt" { }
    }

    
    if {[llength $myLeftoverLUNs] == 0} {
	return "None"
    }

    foreach lun $myLeftoverLUNs {
	send_user "\n## [incr testStep 1]. Deleting LUN straggler: disk=$lun\n"
	send -h "delete PhysicalDisk id=$lun\r"
	validateCommandOutput "delete PhysicalDisk command"
	send_user "\n\n"
    }

    return "True"

}


## Given a list of repository names, find and delete the contents
## of the repository, then delete the repository.
proc deleteRepo {repoList} {

    global testStep
    global send_human
    global failureMsg
    global prompt
    set timeout 600

    array set myRepos [getList Repository]

    if {[array size myRepos] == 0} {
	
	return "None"
    }
   
    set serverList []
    set vmTemplateList []
    set assemblyList []
    set virtualCdromList []
    set virtualDiskList []
    set vmList []      

    set found 0

    foreach repo $repoList {
	if {[info exists myRepos($repo)]} {
	    incr found 1
	    send -h "show repository id=$myRepos($repo)\r"
	    sleep 5
	    expect {
		$failureMsg {
		    set output1 $expect_out(buffer); 
		    expect -re "(.*)$prompt" {};
		    set output2 $expect_out(1,string);
		    send_user "$output1$output2\n\n";
		    return "False"} 
		-re "Presented Server.*?= (.*?) .*?\n\r" \
		    {lappend serverList $expect_out(1,string);exp_continue}
		-re "Vm Template.*?= (.*?) .*?\n\r" \
		    {lappend vmTemplateList $expect_out(1,string);exp_continue}
		-re "Assembl.*?= (.*?) .*?\n\r" \
		    {lappend assemblyList $expect_out(1,string);exp_continue}
		-re "VirtualCdrom.*?= (.*?) .*?\n\r" \
		    {lappend virtualCdromList $expect_out(1,string);exp_continue}
		-re "VirtualDisk.*?= (.*?) .*?\n\r" \
		    {lappend virtualDiskList $expect_out(1,string);exp_continue}
		-re "Vm.*?= (.*?) .*?\n\r" \
		    {lappend vmList $expect_out(1,string);exp_continue}
		-re "(.*)$prompt" {}
		timeout {
		    send_user "Unexpected error occurred while viewing $repo\n"
		    finishRun 2}
	    }
    
	    if {[llength $vmList] > 0} {
		send_user "\n## [incr testStep 1]. Stopping and deleting all VMs associated with $repo...\n"
		foreach object $vmList {
		    send -h "stop vm id=$object\r"
		    sleep 5
		    showCommandOutput "stop vm command"
		    send_user "\n"
		    send -h "delete vm id=$object\r"
		    sleep 4
		    validateCommandOutput "delete vm command"
		    send_user "\n\n"
		}
	    }

    
	    if {[llength $vmTemplateList] > 0} {
		send_user "\n## [incr testStep 1]. Deleting all Templates associated with $repo...\n"
		foreach object $vmTemplateList {
		    send -h "delete vm id=$object\r"
		    sleep 4
		    validateCommandOutput "delete vm command"
		    send_user "\n"
		}
	    }
    
	    
	    if {[llength $virtualDiskList] > 0} {
		send_user "\n## [incr testStep 1]. Deleting all Virtual Disks associated with $repo...\n"
		foreach object $virtualDiskList {
		    send -h "delete virtualdisk id=$object\r"
		    sleep 4
		    validateCommandOutput "delete VirtualDisk command"
		    send_user "\n"
		}
	    }
    
	    if {[llength $virtualCdromList] > 0} {
		send_user "\n## [incr testStep 1]. Deleting all present ISO images, CDROMs, and DVDs...\n"
		foreach object $virtualCdromList {
		    send -h "delete virtualcdrom id=$object\r"
		    sleep 4
		    validateCommandOutput "delete VirtualCdrom command"
		    send_user "\n"
		}
	    }
	    
	    
	    if {[llength $assemblyList] > 0} {
		send_user "\n## [incr testStep 1]. Deleting all Assemblies...\n"
		foreach object $assemblyList {
		    send -h "delete assembly id=$object\r"
		    sleep 4
		    validateCommandOutput "delete assembly command"
		    send_user "\n"
		}
	    }

	    sleep 5
	    
	    send_user "\n## [incr testStep 1]. Deleting Repository: $repo\n"
	    send -h "delete repository id=$myRepos($repo)\r"
	    sleep 4
	    validateCommandOutput "delete repository command"
	    send_user "\n\n"
	}
	
	unset serverList
	unset vmTemplateList
	unset assemblyList
	unset virtualCdromList
	unset virtualDiskList
	unset vmList
 
	set serverList []
	set vmTemplateList []
	set assemblyList []
	set virtualCdromList []
	set virtualDiskList []
	set vmList []     

    }

    if {$found == 0} {
	return "None"
    } else {
	return "True"
    }

}

## Given a list of Server Pool names, remove all servers from
## the server pool, and then delete.
proc deleteServerpool {poolList} {

    global testStep
    global send_human
    global failureMsg
    global prompt
    set timeout 600

    array set myPools [getList ServerPool]

    if {[array size myPools] == 0} {
	return "None"
    }   

    set serverList []
    set masterServer ""
    set serverCount ""

    foreach pool $poolList {
	if {[info exists myPools($pool)]} {
	    send_verbose "Determining servers in Server Pool: $pool....\n"
	    send -h "show serverpool id=$myPools($pool)\r"
	    sleep 4
	    expect {
		$failureMsg {
		    set output1 $expect_out(buffer);
		    expect -re "(.*)$prompt" {};set output2 $expect_out(1,string);
		    send_user "$output1\n$output2\n\n";
		    return "False"}
		-re "Server Count = (.*?)\n\r" {set serverCount $expect_out(1,string); exp_continue}
		-re "Master Server.*?= (.*?) .*?\n\r"  {set masterServer $expect_out(1,string);exp_continue}
		-re "Server .*?= (.*?) .*?\n\r" {lappend serverList $expect_out(1,string);exp_continue}
		-re "(.*)$prompt" {}
		timeout { 
		    send_user "An unexpected error occurred while retrieving ServerPool information\n"
		    return "False"}
	    }
    
	    send_user "\n## [incr testStep 1]. Removing servers from $pool\n"
	    foreach object $serverList {
		if { $object != $masterServer } {
		    send -h "remove server id=$object from serverpool id=$myPools($pool)\r"
		    sleep 3
		    validateCommandOutput "remove server command"
		} 
	    }
	    
	    if { $masterServer != "" } {
		send_user "\n## [incr testStep 1]. Removing the master server from $pool\n"
		send -h "remove server id=$masterServer from serverpool id=$myPools($pool)\r"
		sleep 3
		validateCommandOutput "remove server command"
	    }
	    
	    send_user "\n## [incr testStep 1]. Deleting the Server Pool: $pool\n"
	    send -h "delete serverpool id=$myPools($pool)\r"
	    sleep 3
	    validateCommandOutput "delete serverpool command"
	}

	set serverList []
	set masterServer ""
	set serverCount ""
    }

    return "True"
}

## Given an object type (Server, VM, PhysicalDisk, etc.) get 
## a list of all Object IDs known to the Manager for that
## object type.
proc getList {object} {

    global testStep
    global send_human
    global failureMsg
    global prompt

    set timeout 600

    set exitcode "False"
    array set myObj {}

    expect "*"

    send -h "list $object\r"
    sleep 5
    expect {  
        $failureMsg {
            set output1 $expect_out(buffer); 
            expect -re "(.*)$prompt" {};
            set output2 $expect_out(1,string);
            send_user "$output1\n$output2\n\n";
            set exitcode "False"}
        -re ".*None*" {
            send_verbose "Found no $object objects...\n"
            set exitcode "True"}
        -re "id:(.*?) name:(.*?)\n\r" { 
            send_verbose "Found $object: $expect_out(2,string)\n"
            set myObj([string trim $expect_out(2,string)]) [string trim $expect_out(1,string)]
	    set exitcode "True"
            exp_continue}
        -re "(.*)$prompt" {
	    set exitcode "True"}
    }
    

    if {$exitcode == "False"} {
	send_user "An unexpected error has occurred while viewing $object information,"
        finishRun 2
    }

    return [array get myObj]
}

## Copy logs from one of the OVM servers to 
## our log directory for inclusion in the 
## tarball that gets sent back to Oracle.
proc copyLog {server password filename logdir newfilename} {

    global send_human
    set match_max 10000
    set success "True"
    set timeout -1

    set myString "root\@$server\:$filename"
    append logdir $newfilename

    expect "*"
    
    spawn scp $myString $logdir; set spawn_id1 $spawn_id
    sleep 5
    expect {
	-i $spawn_id1 -re ".*Are you sure you want to continue connecting.*?" {
	    send_user "$expect_out(buffer)\nSending yes to the host....\n"; 
	    send "yes\r";
	    exp_continue
	}  
	-i $spawn_id1 -re ".+? password:" {
	    send_user "\nSending password...\n"; 
	    send "$password\r";
	    exp_continue
	}
	-i $spawn_id1 -re ".+? No route to host\r" {
	    send_user "Failed to connect to $server: No route to host.\nPlease check your network connection and try again.\n"
	    set success "False"
	}
	-i $spawn_id1 -re "Connection closed .+?\r" {
	    send_user "\nFailed to connect to $server: Connection closed by remote host.\n"
	    set success "False"
	}
	-i $spawn_id1 -re ".+? No such file or directory\r" {
	    send_user "\nFailed to copy $filename: No such file or directory!\n"
	    set success "False"
	}
	
    }
    
    return $success

}


## Collect server data using sosreport.  Login to each 
## of the OVS servers and run sosreport, then send the
## full path to the results file back so that the 
## report can be copied to the log directory. 
proc runSOS {server logdir ticket} {

    global send_human
    set match_max 10000
    set timeout 600
    set soshome "/tmp/"
    set success "true"

    send_user "\nExecuting sosreport; this can take several minutes...\n"
    send -h "sosreport --batch --ticket-number='$ticket' --name='$server' --tmp-dir=$soshome\r"
    sleep 5
    expect {
	-re "usage: .+?" {
	    send -h "sosreport --batch --ticket-number='$ticket' --name='$server'\r"
	    exp_continue
	}
	-re "^sosreport .+?" {
	    exp_continue;
	}
	-re "(/tmp/)(sosreport\-.+?\r)" {
	    set soshome $expect_out(1,string)
	    set sosreport $expect_out(1,string)
	    append sosreport $expect_out(2,string)
	    set sosname $expect_out(2,string)
	    exp_continue
	}
	-re "The md5sum is: (.+?)\r" {
	    set md5sum $expect_out(1,string)
	    exp_continue
	}
	"Please send this file to your support representative." { set success "True" }
	timeout {
	    set sosreport "False"
	}
    }
    

    if {$sosreport == "False"} {
	send_user "Watchdog timeout after 15 minutes: sosreport did not complete!\n"
	return $sosreport
    }


    ### The name of the sosreport is long, and when we try to
    ### copy it to the machine where the log directory is
    ### the length of the string used to spawn the scp command
    ### overflows expect's send buffer, and prevents the
    ### command from being executed correctly.  Since it's 
    ### important to preserve the name of the sosreport, the 
    ### workaround is to create a tarball with a shorter name
    ### that can be copied without overflowing the buffer.
    send_user "sosreport was generated in: $sosreport\n"
    send_user "The md5sum for the sosreport is: $md5sum\n\n"
    send_user "Now creating a tarball with the sosreport so that it can be copied to the log directory...\n"


    set tarname "$soshome$server-soreport.tar"
    send_user "Creating the new tarball....\n"

    set timeout 60
    send -h "tar -cf $tarname $sosreport\r"
    expect {
	-re "tar: .+?: No such file or directory\r" { 
	    set success "False"; 
	    send_user "\n\nCreation of the tarball failed: no such file or directory.\n" 
	}
	"tar: Error exit delayed from previous errors\r" {
	    set success "False";
	    send_user "\n\nCreation of the tarball failed: Exit delayed from previous errors.\n" 
	}
	"tar: Removing leading `/' from member names\r" {
	    set success "True"
	}
    }

    if {$success == "False"} {
	return $success
    } else {	
	return $tarname
    }
}

## We also want to chat with multipathd to see how
## it's configured.  Copy the output to a file
## so that we can keep that with all of the logs.
proc runMultipathd {filename} {

    global send_human
    set success "False"

    ## Since we're redirecting all of the output to a file, we have
    ## no way to know if the call to multipathd succeeded or failed.
    ## so we just try to clear the expect buffer after the call so
    ## that we can read from it later
    send_user "Sending multipathd command.  This will take a moment...\n"
    send -h "echo \"show config\" | multipathd -k > $filename\r"
    expect {
	-re "(.*)\r" {
	   exp_continue
	}
    }

    expect "*"
    sleep 20

    ## Since this file is on a remote server, we can't just
    ## use the tcl "file exists" function to see if the output
    ## file was written, but since we're already logged into 
    ## this machine, why not just use file to tell us if the 
    ## the output file exists and is a txt file, as expected?
    send_verbose "Verifying output was captured in $filename...\n"
    send -h "file $filename\r"
    expect {
	-re "Usage: .*?" {
	    send_verbose "Failed capturing output from multipathd.\n"
	}
	-re ".*?Error:.*?No such file or directory.*?\r" {
	    send_verbose "Failed capturing output from multipathd.\n"
	}
	-re "(.*?)$filename: ASCII text\r" {
	    set success "True"
	    send_verbose "multipathd output was captured successfully.\n"	    
	}
    }

    expect "*"
    return $success

}


## This is especially for handling the sosreports, 
## we need to be able to grab the filename out of
## the full path
proc getFileName {fullpath} {

    set filename "False"

    set mypath [string trimright $fullpath "/"]
    set chunks [split $fullpath "/"]
    set numchunks [llength $chunks]
    
    if {$numchunks >= 1} {
	set filename [lindex $chunks [expr $numchunks - 1]]
    } 

    return $filename
}

proc tallyResults {} {

    global testList
    global testStatus

    if {[info exists testList] != 0} {

	send_user "\n--------------------------------------------------------------------------\n"
	send_user "\n\nIndividual Test Case Results:\n"
	
	foreach test $testList {
	    send_user "$test ................................ $testStatus($test,status)\n"	
	}
    }

    return
}


## Cleanly exit from the script.
proc finishRun {exitcode} {

    ## For exit codes 0 (successful finish), and 2 (failure of an OVM command)
    ## we need to close the ssh session manually.  Other exit codes mean 
    ## something else like a timeout, or a crash, or expect operating
    ## on ovm output out of order, etc., has occurred; in which case, the ssh 
    ## session has already been terminated...
    if {$exitcode == 0} {
	send_user "\nExiting.\n\n"
	close
    }

    if {$exitcode == 2} {
	send_user "\n\nA fatal error has been encountered, from which recovery is impossible at this time.\nExiting.\n\n"
	close
    }	

    tallyResults    

    # Close down the logfile.
    log_file

    exit $exitcode
}


trap {
    ## Since we play with stty settings, make
    ## sure to make them sane if we receive
    ## keyboardinterrupt.
    stty sane
    send_user "\nCaught user requested interrupt.\nTerminating...\n"
    exit 9
} SIGINT
    
