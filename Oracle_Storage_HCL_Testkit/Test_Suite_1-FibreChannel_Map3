#!/usr/bin/expect

##
##    The Oracle Storage HCL Testkit is a suite of tests for certifying
##    storage with Oracle VM (OVM).
##    Copyright (C) 2013 Oracle USA, Inc 
##
##    This file is part of the Oracle Storage HCL Testkit.
##
##    The Oracle Storage HCL Testkit is free software; you can redistribute 
##    it and/or modify it under the terms of the GNU General Public License 
##    as published by the Free Software Foundation; either version 2 of the 
##    License, or (at your option) any later version.
##
##    The Oracle Storage HCL Testkit is distributed in the hope that it will
##    be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
##    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License
##    along with the Oracle Storage HCL Testkit.  If not; write to the 
##    Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
##    Boston, MA 02110-1301 USA. Or see <http://www.gnu.org/licenses/>.
##

source commonExpectDef.cli

################ global variables #####################
set prompt "OVM> "
set VERBOSE [lindex $argv 2]
set send_human {.1 .3 1 .05 2}

set successMsg "Status: Success"
set failureMsg "Status: Failure"
set timeout 900

set myRepo ""
set myPoolFS ""
set repoDiskName ""
set poolfsDiskName ""
set sharedSpare ""
set spareDiskName ""

########## externally defined variables ############
set ovmUser ${ovmUser}
set adminServer ${adminServer}
set ovmPassword [lindex $argv 0]
set ovmAgentUsername ${ovmAgentUsername}
set ovmAgentPassword [lindex $argv 1]
set ovmServerMasterIP ${ovmServerMasterIP}
set ovmServerSlaveIP ${ovmServerSlaveIP}


## Pool Parameters
set serverPoolName fc_testpool1
set serverPoolIP ${serverPoolIP}

## Repository Parameters
set repoName repo_fc1.1
set vdiskName vdisk_fc1.1

## VM Parameters
set vmName VM_fc1.1

## Network
set VM_Network ${VM_Network}
set VM_Netmask ${VM_Netmask}
set VM_NetworkPort ${VM_NetworkPort}
set ovmServerMaster_vmnetworkIP ${ovmServerMaster_vmnetworkIP} 
set ovmServerSlave_vmnetworkIP ${ovmServerSlave_vmnetworkIP} 
set vNIC 00:21:f6:ca:fe:ba
set vNIC1 00:21:f6:ca:fe:b2
set vNIC2 00:21:f6:ca:fe:b1

## Storage
set SAN_ServerName "Unmanaged FibreChannel Storage Array"
set storageNetworkPort "generic"


## Logging
set hcllogdir ${hcllogdir}
set logfile $hcllogdir
append logfile "FibreChannel_TestSuite1-Map3.log"
set testStep 0

####################################################################
##
##       Test Suite 1: Fibre Channel with Generic Plugin
##
####################################################################
##
##      +-----+-------+-------+---------------+---------------+
##      | LUN |  Old  |  New  | OVM Server #1 | OVM Server #2 |
##      +-----+-------+-------+---------------+---------------+
##      |  1  |  7 GB |       |               |               |
##      |  2  | 12 GB |       |               |               |
##      |  3  |  2 GB |       |   unmapped    |   unmapped    |
##      |  4  |  5 GB | 15 GB |       X       |       X       |
##      |  5  | 10 GB | 20 GB |       X       |       X       |
##      |  6  | 30 GB |       |       X       |       X       |
##      +-----+-------+-------+---------------+---------------+
##

log_user 0
OVMlogin
log_file -a $logfile

send_user "\nReading server info...\n"
set slist [getServerIDs]
array set myServerInfo [verifyServers $ovmServerMasterIP $ovmServerSlaveIP $storageNetworkPort $VM_NetworkPort $slist]

if {[info exists myServerInfo($ovmServerMasterIP,name)]} {
    set masterName $myServerInfo($ovmServerMasterIP,name)
} else {
    send_user "The server $ovmServerMasterIP cannot be found!\n"
    send_user "Exiting...\n"
    finishRun 4
}
if {[info exists myServerInfo($ovmServerSlaveIP,name)]} {
    set secondaryName $myServerInfo($ovmServerSlaveIP,name)
} else {
    send_user "The server $ovmServerSlaveIP cannot be found!\n"
    send_user "Exiting...\n"
    finishRun 4
}

set masterID $myServerInfo($ovmServerMasterIP,id)
set secondaryID $myServerInfo($ovmServerSlaveIP,id)


send_user "\n---------------------------------------------------------------------------------\n"
send_user "GSFC-106: Resize and unmap LUNs mapped to both servers"
send_user "\n---------------------------------------------------------------------------------\n"
set testStep 0

send_user "\n## [incr testStep 1]. Refreshing  $SAN_ServerName\n"
send "refresh SanServer name='$SAN_ServerName'\r"
validateCommandOutput "refresh SanServer command"

send_user "\nWaiting 120 seconds for everything to settle....\n"
sleep 120

send_user "First verifying the resize...\n"
array set diskList1 [getDisks $ovmServerMasterIP [array get myServerInfo]]
array set diskList2 [getDisks $ovmServerSlaveIP [array get myServerInfo]]

## Initially, we need to include the disksize of the LUN
## that we are expecting to have been unmapped.  This is
## because we need the list of disks before they've been
## refreshed to know their initial sizes.  If we did the 
## delete first, we would lose this info.
set sizelist {2 15 20 30}


send_user "\nDetermining initial LUN sizes on $secondaryName, in order to\n"
send_user "verify the changes after the disks have already been refreshed.\n"

array set secondDiskSizes {}
set length [array size diskList2]
for {set i 0} {$i < $length} {incr i 1} {
    set secondDiskSizes($i) [getDiskSize $diskList2($i)]
}

send_user "\nExaminging the disks on $masterName to verify\n"
send_user "that the LUN size changes are visible.  This will take a momemt.\n"
set length [array size diskList1]
set rcount 0 

for {set i 0} {$i < $length} {incr i 1} {
    if {[refreshAndVerifySize $diskList1($i) $sizelist] == "True"} {
	incr rcount 1
    }
} 

if {$rcount != 2} {
    send_user "Expected 2 LUNs from $masterName to be resized, but found $rcount instead!\n"
    finishRun 2
}
send_user "\nSuccessfully verified new LUN sizes on $masterName.\nContinuing.\n"


send_user "\nVerifying the LUN resizing is visible on $secondaryName\n"
set rcount [verifyResize [array get diskList2] [array get secondDiskSizes] $sizelist]
if {$rcount != 2} {
    send_user "Expected 2 LUNs from $secondaryName to be resized, but found $rcount instead!\n"
    finishRun 2
}

send_user "The LUNs have been correctly resized!\n\n"
send_user "Now verifying that the LUN was unmapped...\n"

set expectedMap1 [expr [array size diskList1] - 1]
set expectedMap2 [expr [array size diskList2] - 1]

set expectedUnmap1 1
set expectedUnmap2 1


## Now iterate through the disklists, and check the status
## of each disk.  In 3.2.1, this is the only way to know 
## whether or not a disk is mapped via the CLI.  Unmapped
## LUNs can be deleted, because they're only being deleted
## from the manager's inventory list, they're not actually 
## being deleted from the server.....
send_user "Beginning the process of verifying whether each disk is in a mapped\n"
send_user "or unmapped state.  LUNs which are marked as unmapped or offline\n"
send_user "will be deleted from the disklist so that they are not accidentally\n"
send_user "used in future tests.\n"

send_user "\n## [incr testStep 1]. Refreshing  $SAN_ServerName\n"
send "refresh SanServer name='$SAN_ServerName'\r"
validateCommandOutput "refresh SanServer command"

send_user "\nWaiting 120 seconds for everything to settle....\n"
sleep 120

send_user "\nVerifying LUNs on $masterName.  "
set dcount [deleteLUNs [array get diskList1]]
if {$dcount == $expectedUnmap1} {
    send_user "Successfully deleted $expectedUnmap1 LUNs from $masterName\n"
    send_user "Waiting 120 seconds for everything to settle....\n\n"
    sleep 120
} else {
    send_user "Expected $expectedUnmap1 unmapped LUNs on $masterName,"
    send_user "but found $dcount unmapped LUNs; all of which were deleted!\n"
    finishRun 4
}

send_user "Verifying the changes are visible on $secondaryName\n"
array set diskList3 [getDisks $ovmServerSlaveIP [array get myServerInfo]]
set expectedMap [array size diskList3]

## By the time we get here, the smallest LUN should have
## been unmapped and deleted from the disk list, so we
## can say that only these sizes are expected at this 
## point.
set sizelist {15 20 30}

set success [verifyExpectedMaps [array get diskList3] $expectedMap 0 $sizelist]
if {$success == "False"} {
    finishRun 2
}

finishRun 0
